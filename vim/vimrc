" Aaron's vimrc
" Started with Jay's vimrc as a base
" Most taken from others on the internet
" Date: Fri Feb 20 2009
"
" Notes/Tips:
" - Here a discovery I made today when you have multiple buffers open try
" Ctrl-Shift-` (or Ctrl-~ however you want to think about it). I don't totally
" understand it yet, but it's neat. It may be some quick alternate file switch.

" set the windows size
"set lines=44
"set columns=101

set title " Makes titlestring change the window title.
set noicon " See the help.
set history=50 " Lines of command line history to keep.
set autowrite " Automatically save modifications to files when you use critical commands.
set nobackup " Backups are for wimps ;-)
set nowritebackup " Before writing file make a backup.
"set confirm " Confirm quit and other operations if file has changed (no need for !)

set backspace=2 " Same as :set backspace=indent,eol,start
set nocompatible " No backwards compatibility with vi
set digraph " Required for those umlauts.
set noerrorbells " No more beep! ;-)
set visualbell t_vb= " Terminal's visual bell - turned off to make Vim quiet!
set esckeys " esckeys: allow usage of cursor keys within insert mode
set formatoptions=cqrow " Options for the "text format" command ("gq")
" c - format comments
" q - format comments with gq
" r - insert current comment leader when hitting <Enter>
" t - format text (should be removed for code)
" o - similar to r except only comment leader"+
" a - reflow text automatically"+
" n - recognize numbered lists"+
" w - trailing whitespace means paragraph continues
" 2 - use second line of paragraph for formatting

set textwidth=90 " Max width of text being entered.
set helpheight=0 " Zero disables helpheight (see the help section).

set hlsearch "set noh " Highlight matches when searching.
set incsearch "set noincsearch " Start searching right away.
set ignorecase " Ignore the case in search patterns.
set smartcase " If the first letter if capitalized search is case sensitive.
set laststatus=2 " Show status line always!
set lazyredraw " Do not update screen while executing macros.
set ruler " Show cursor position?  Yep!

" The following always keep a bit of context on the screen around the cursor.
set scrolljump=1 " When scrolling this is how many lines to jump.
set scrolloff=3 " This is how many lines to keep above or below cursor.
set sidescroll=1 " Same as scrolljump but for the horizontal
set sidescrolloff=6 " Same as above but for horizontal.
" sidescrolloff test garbage: asldkfj;alskjdfffffIfffffffffffffffffffffffffffffffffffffffffffffffffffal;skdjf;lkasjdfl;kjal;skdfffffffffffffalksdjf;lkasjdffffffffffffffffl;aksjdf

set clipboard=autoselect " Copy text to clipboard in visual mode
set wildmenu " Way cool completion in command line mode
set wildmode=full " This is the default

" Shell to use for :!
"if has("unix")
"set shell=bash
"elseif has("win32")
"set shell=cmd.exe
"endif

" These are a personal choice
set autoindent
set smartindent
set shiftwidth=4 " Number of spaces to use for each insertion of (auto)indent.
set tabstop=4 " What <Tab> is worth in spaces.
set softtabstop=4 " Feel like tabs, but they're really spaces.
"set expandtab " Changes tabs to spaces when on.
set foldmethod=indent " turn on folding
set guifont=Lucida_Console:h10:cDEFAULT
colorscheme wombat

" when list is on show whitespace characters like follows
set listchars=tab:>-,trail:-,eol:$,extends:>,precedes:<
" set invlist " <--These toggles showing these characters

filetype plugin indent on " automatically figure out what kind of file we're working with
set shortmess=aostITO " Kind of messages to show. Abbreviate them all!
set showcmd " Show current uncompleted command? Absolutely!
set showmatch " Briefly jump to the matching brace when typed
set showmode " Show the current mode at the bottom.

" Ignore filename with any of these suffixes (for autocompletion)
set suffixes=.aux,.bak,.dvi,.idx,.log,.ps,.pdf,.swp,.tar,.o,.class

set ttyfast " Are we using a fast terminal? setting depends Vim usage...
"set nottybuiltin " search external termcaps first
"set ttyscroll=0 " Turn off scrolling (faster)!
set nostartofline " Do not jump to first character with page commands. Keep the cursor in the current column.
set splitbelow " When splitting a window, put the new window below.
set viminfo=c,%,'50,"100,:100,h,n.viminfo " Info to store in the viminfo file for next session.

" ===============================================================
" Wrap commands
" ===============================================================
set whichwrap=b,s,<,>,h,l,[,],~ " These keys follow the line wrap.
set virtualedit= " virtualedit=all lets cursor move anywhere.
"wrapmargin=1 " How far from the right window border to start wraping
set nowrap " I don't want vim to wrap lines

" ===============================================================
" Window commands
" ===============================================================
" These allow us to switch more easily between windows
" <C-W>_ Switches windows (end for maximizing)
map <C-J> <C-W>j
" <C-W>_ Switches windows (end for maximizing)
map <C-K> <C-W>k
" <C-W>_ Switches windows (end for maximizing)
map <C-H> <C-W>h
" <C-W>_ Switches windows (end for maximizing)
map <C-L> <C-W>l
" Maximizes current window
map _ <C-W>_
" The following have problems right now. The cursor moves with the operation.
" makes window larger
map + <C-W>+
" makes window smaller
map - <C-W>-

" ===============================================================
" Abbreviations
" ===============================================================

" grab the date/time.. output looks like :
" Fri Nov 10 03:18:44 MST 2000 
iab YDT <C-R>=strftime("%a %b %d %Y")<CR>
imap <C-D> <C-R>=strftime("%a %b %d %T %Z %Y")<CR>

" ===================================================================
" Plugins
" ===================================================================

" Just move it to the plugin directory instead
" source $VIMRUNTIME/macros/matchit.vim
let snippetsEmu_key = "<F4>"

" ===================================================================
" MAPpings
" ===================================================================

" Reload this file
if has("unix")
	nmap <F12> :source ~/.vimrc<CR>
elseif has("win32")
	nmap <F12> :source ~/_vimrc<CR>
endif

" Make Y behave like C and D
nmap Y y$

" Paste at current tab level (doesn't work that great)
"nmap p ]p
"
" Re-tab whole file
nmap <F6> mzgg=G`z

" toggle line numbering
nmap <C-N> :set invnumber<CR>

" Don't use Ex mode, use Q for formatting
noremap Q gq

" 'o' in insert mode
inoremap <C-CR> <C-O>o

" For unix I've found the + register to work best, for windows *.
" vim to system clipboard
map <F9> :let @+=@"<CR>

" system clipboard to vim
map <F10> :let @"=@+<CR>

" NERDTree toggle
map <F2> :NERDTreeToggle<CR>

" Stop \n at end of file
autocmd FileType php setlocal noeol binary

" ';;' inserts a ';' at the end of the line (';' is a problem with 'for(;;)')
"inoremap ;; <Esc>A;

" I don't use ; in normal mode so here it puts a ; at the end of the line
"noremap ; mzA;<Esc>`z

" The following avoid jumping over wrapped lines
imap <Down> <C-O>gj
nmap j gj
imap <Up> <C-O>gk
nmap k gk

" Movements in insert mode
imap <C-L> <Right>
imap <C-K> <Up>
imap <C-J> <Down>
" How do I do left in insert mode?
" I like <C-H> as backspace, I can't get meta to work
imap <C-U> <Left>

" ===================================================================
" Functions
" ===================================================================

" tab expansion in insert mode:
function! InsertTabWrapper(dir)
	let col = col('.')-1
	if(!col || getline('.')[col-1] !~ '\k')
		return "\<Tab>"
	elseif a:dir == "backward"
		return "\<C-P>"
	else
		return "\<C-N>"
	endif
endf
inoremap <Tab> <C-R>=InsertTabWrapper("forward")<CR>
inoremap <S-Tab> <C-R>=InsertTabWrapper("backward")<CR>

" paranthesis matchers
inoremap ( (<C-V>)<Left>
inoremap ) <C-R>=ClosePair(')')<CR>
inoremap [ [<C-V>]<Left>
inoremap ] <C-R>=ClosePair(']')<CR>
inoremap { {<C-V>}<Left>
inoremap } <C-R>=ClosePair('}')<CR>
function! ClosePair(char)
	if(getline('.')[col('.')-1] == a:char)
		return "\<Right>"
	else
		return a:char
	endif
endf



" =================================================================== 
" SESSION STuff
" ===================================================================
" don't store any options in sessions
if version >= 700
	" localoptions has to be here:
	" for some reason, new session loading code fails to set filetype of files in session
  set sessionoptions=blank,tabpages,folds,localoptions,curdir,resize,winsize,winpos
endif

command! -nargs=1 Project :call LoadProject('<args>')
command! -nargs=+ SaveProject :call SaveProject('<args>')

let s:projectloaded = 0
let s:loadingproject = 0
let s:projectname = ''

function! LoadProject(name)

	let s:projectloaded = 1
	let s:projectname = a:name
	exe "source ~/vimfiles/projects/".a:name.".vim"
	exe "rviminfo! ~/vimfiles/projects/".a:name.".viminfo"

endfunction

function! SaveProject(name)

	if a:name ==# ''
		if s:projectloaded == 1
			let pname = s:projectname
		endif
	else
		let pname = a:name
	endif

	if pname !=# ''
		let s:projectloaded = 0
		let s:projectname = ''
		exe "mksession! ~\\vimfiles\\projects\\".pname.".vim"
		exe "wviminfo! ~\\vimfiles\\projects\\".pname.".viminfo"
	endif

endfunction

autocmd VimLeave * call SaveProject()


 
"let s:sessionloaded = 0
"let s:loadingsession = 0
"let s:sessionfile = ''
"let s:netrwsort = ''
"autocmd BufRead *.vim call LoadSessionFinish()
"function LoadSession()
"	" save current netrw sort sequence
"	let s:netrwsort = g:netrw_sort_sequence
"	" show sessions first, then dirs
"	let g:netrw_sort_sequence = '\.vim$,[\/]$'
"	let s:loadingsession = 1
"	e .
"endfunction
"function LoadSessionFinish()
"	if s:loadingsession == 1
"		let s:loadingsession = 0
"		let s:sessionloaded = 1
"		" restore previous sort sequence setting
"		let g:netrw_sort_sequence = s:netrwsort
"		" save session filename for saving on exit
"		let s:sessionfile = bufname('%')
"		source %
"	end
"endfunction
"function SaveSession()
"  if s:sessionloaded == 1
"		let s:sessionloaded = 0
"		" re-save session before exiting
"    exe "mksession! ".s:sessionfile
"  end
"endfunction
"autocmd VimLeave * call SaveSession()



" =================================================================== 
" AutoCommands
" ===================================================================

" Autocommands are the key to "syntax coloring".
" There's one command in your vimrc that should
" load/source the file $VIM/syntax/syntax.vim
" which contains the definition for colors and
" the autocommands that load other syntax files
" when necessary, ie when the filename matches
" a given pattern, eg "*.c" or *".html".
"
" just load the main syntax file when Vim was compiled with "+syntax"
if has("syntax")
	" The following sources the main syntax file,
	" ie. "$VIM/syntax/syntax.vim", see ":help :syn-on":
	syntax on
	" Redefine the color for "Comment":
	" hi! Comment  term=bold  ctermfg=cyan  guifg=red

	" The standard background color for the GUI Vim is "blue".
	" No, I don't know why.  But many users want to change this
	" color to black so they can read the blue colored text.  ;-)
	" Here's how:
	" :hi Normal guibg=white guifg=black
endif

autocmd FileType text set formatoptions+=t | set textwidth=78

" autocmd BufEnter * let &titlestring = hostname() . " - " . expand ("%:~:p")
autocmd BufEnter * let &titlestring = expand ("%:t")

" Jump to last cursor position
autocmd BufReadPost *
			\ if line("'\"") > 0 && line("'\"") <= line("$") |
			\   exe "normal g`\"" |
			\ endif

